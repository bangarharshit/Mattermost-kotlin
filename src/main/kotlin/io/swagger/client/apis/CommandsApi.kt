/**
* Mattermost API Reference
* ### API version 4 is stable with the Mattermost server 4.0 release. API version 3 is scheduled for deprecation on January 16th, 2018. [Details here](/#tag/APIv3-Deprecation). Looking for the APIv3 reference? It has moved [here](https://api.mattermost.com/v3). 
*
* OpenAPI spec version: 4.0.0
* Contact: feedback@mattermost.com
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/
package io.swagger.client.apis

import io.swagger.client.models.AppError
import io.swagger.client.models.Body_38
import io.swagger.client.models.Body_39
import io.swagger.client.models.Command
import io.swagger.client.models.CommandResponse
import io.swagger.client.models.Inline_response_200_8
import io.swagger.client.models.StatusOK

import io.swagger.client.infrastructure.*

class CommandsApi(basePath: kotlin.String = "http://your-mattermost-url.com/api/v4") : ApiClient(basePath) {

    /**
    * Delete a command
    * Delete a command based on command id string. ##### Permissions Must have &#x60;manage_slash_commands&#x60; permission for the team the command is in. 
    * @param commandId ID of the command to delete 
    * @return StatusOK
    */
    @Suppress("UNCHECKED_CAST")
    fun commandsCommandIdDelete(commandId: kotlin.String) : StatusOK {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/commands/{command_id}".replace("{"+"command_id"+"}", "$commandId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<StatusOK>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as StatusOK
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Update a command
    * Update a single command based on command id string and Command struct. ##### Permissions Must have &#x60;manage_slash_commands&#x60; permission for the team the command is in. 
    * @param commandId ID of the command to update 
    * @param body  
    * @return Command
    */
    @Suppress("UNCHECKED_CAST")
    fun commandsCommandIdPut(commandId: kotlin.String, body: Command) : Command {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/commands/{command_id}".replace("{"+"command_id"+"}", "$commandId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Command>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Command
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Generate a new token
    * Generate a new token for the command based on command id string. ##### Permissions Must have &#x60;manage_slash_commands&#x60; permission for the team the command is in. 
    * @param commandId ID of the command to generate the new token 
    * @return Inline_response_200_8
    */
    @Suppress("UNCHECKED_CAST")
    fun commandsCommandIdRegenTokenPut(commandId: kotlin.String) : Inline_response_200_8 {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/commands/{command_id}/regen_token".replace("{"+"command_id"+"}", "$commandId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Inline_response_200_8>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Inline_response_200_8
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Execute a command
    * Execute a command on a team. ##### Permissions Must have &#x60;use_slash_commands&#x60; permission for the team the command is in. 
    * @param body command to be executed 
    * @return CommandResponse
    */
    @Suppress("UNCHECKED_CAST")
    fun commandsExecutePost(body: Body_39) : CommandResponse {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/commands/execute",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<CommandResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as CommandResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * List commands for a team
    * List commands for a team. ##### Permissions &#x60;manage_slash_commands&#x60; if need list custom commands. 
    * @param teamId The team id. (optional)
    * @param customOnly To get only the custom commands. If set to false will get the custom if the user have access plus the system commands, otherwise just the system commands.  (optional, default to false)
    * @return kotlin.Array<Command>
    */
    @Suppress("UNCHECKED_CAST")
    fun commandsGet(teamId: kotlin.String, customOnly: kotlin.String) : kotlin.Array<Command> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("teamId" to listOf("$teamId"), "customOnly" to listOf("$customOnly"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/commands",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Command>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Command>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Create a command
    * Create a command for a team. ##### Permissions &#x60;manage_slash_commands&#x60; for the team the command is in. 
    * @param body command to be created 
    * @return Command
    */
    @Suppress("UNCHECKED_CAST")
    fun commandsPost(body: Body_38) : Command {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/commands",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Command>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Command
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * List autocomplete commands
    * List autocomplete commands in the team. ##### Permissions &#x60;view_team&#x60; for the team. 
    * @param teamId Team GUID 
    * @return kotlin.Array<Command>
    */
    @Suppress("UNCHECKED_CAST")
    fun teamsTeamIdCommandsAutocompleteGet(teamId: kotlin.String) : kotlin.Array<Command> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/teams/{team_id}/commands/autocomplete".replace("{"+"team_id"+"}", "$teamId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Command>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Command>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

}
