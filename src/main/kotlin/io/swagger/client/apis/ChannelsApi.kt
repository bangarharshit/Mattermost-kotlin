/**
* Mattermost API Reference
* ### API version 4 is stable with the Mattermost server 4.0 release. API version 3 is scheduled for deprecation on January 16th, 2018. [Details here](/#tag/APIv3-Deprecation). Looking for the APIv3 reference? It has moved [here](https://api.mattermost.com/v3). 
*
* OpenAPI spec version: 4.0.0
* Contact: feedback@mattermost.com
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/
package io.swagger.client.apis

import io.swagger.client.models.AppError
import io.swagger.client.models.Body_22
import io.swagger.client.models.Body_23
import io.swagger.client.models.Body_24
import io.swagger.client.models.Body_25
import io.swagger.client.models.Body_26
import io.swagger.client.models.Body_27
import io.swagger.client.models.Channel
import io.swagger.client.models.ChannelMember
import io.swagger.client.models.ChannelNotifyProps
import io.swagger.client.models.ChannelStats
import io.swagger.client.models.ChannelUnread
import io.swagger.client.models.Inline_response_200_5
import io.swagger.client.models.PostList
import io.swagger.client.models.Roles_1
import io.swagger.client.models.StatusOK

import io.swagger.client.infrastructure.*

class ChannelsApi(basePath: kotlin.String = "http://your-mattermost-url.com/api/v4") : ApiClient(basePath) {

    /**
    * Delete a channel
    * Delete a channel based from provided channel id string. ##### Permissions &#x60;delete_public_channel&#x60; permission if the channel is public, &#x60;delete_private_channel&#x60; permission if the channel is private, or have &#x60;manage_system&#x60; permission. 
    * @param channelId Channel GUID 
    * @return StatusOK
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsChannelIdDelete(channelId: kotlin.String) : StatusOK {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/channels/{channel_id}".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<StatusOK>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as StatusOK
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get a channel
    * Get channel from the provided channel id string. ##### Permissions &#x60;read_channel&#x60; permission for the channel. 
    * @param channelId Channel GUID 
    * @return Channel
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsChannelIdGet(channelId: kotlin.String) : Channel {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/channels/{channel_id}".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Channel>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Channel
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get channel members
    * Get a page of members for a channel. ##### Permissions &#x60;read_channel&#x60; permission for the channel. 
    * @param channelId Channel GUID 
    * @param page The page to select. (optional, default to 0)
    * @param perPage The number of members per page. (optional, default to 60)
    * @return kotlin.Array<ChannelMember>
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsChannelIdMembersGet(channelId: kotlin.String, page: kotlin.String, perPage: kotlin.String) : kotlin.Array<ChannelMember> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("page" to listOf("$page"), "perPage" to listOf("$perPage"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/channels/{channel_id}/members".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<ChannelMember>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ChannelMember>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get channel members by ids
    * Get a list of channel members based on the provided user ids. ##### Permissions Must have the &#x60;read_channel&#x60; permission. 
    * @param channelId Channel GUID 
    * @param userIds List of user ids 
    * @return kotlin.Array<ChannelMember>
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsChannelIdMembersIdsPost(channelId: kotlin.String, userIds: kotlin.Array<kotlin.String>) : kotlin.Array<ChannelMember> {
        val localVariableBody: kotlin.Any? = userIds
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/channels/{channel_id}/members/ids".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<ChannelMember>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ChannelMember>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Add user to channel
    * Add a user to a channel by creating a channel member object.
    * @param channelId The channel ID 
    * @param body  
    * @return ChannelMember
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsChannelIdMembersPost(channelId: kotlin.String, body: Body_26) : ChannelMember {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/channels/{channel_id}/members".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ChannelMember>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ChannelMember
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Remove user from channel
    * Delete a channel member, effectively removing them from a channel. ##### Permissions &#x60;manage_public_channel_members&#x60; permission if the channel is public. &#x60;manage_private_channel_members&#x60; permission if the channel is private. 
    * @param channelId Channel GUID 
    * @param userId User GUID 
    * @return StatusOK
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsChannelIdMembersUserIdDelete(channelId: kotlin.String, userId: kotlin.String) : StatusOK {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/channels/{channel_id}/members/{user_id}".replace("{"+"channel_id"+"}", "$channelId").replace("{"+"user_id"+"}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<StatusOK>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as StatusOK
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get channel member
    * Get a channel member. ##### Permissions &#x60;read_channel&#x60; permission for the channel. 
    * @param channelId Channel GUID 
    * @param userId User GUID 
    * @return ChannelMember
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsChannelIdMembersUserIdGet(channelId: kotlin.String, userId: kotlin.String) : ChannelMember {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/channels/{channel_id}/members/{user_id}".replace("{"+"channel_id"+"}", "$channelId").replace("{"+"user_id"+"}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ChannelMember>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ChannelMember
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Update channel notifications
    * Update a user&#39;s notification properties for a channel. Only the provided fields are updated. ##### Permissions Must be logged in as the user or have &#x60;edit_other_users&#x60; permission. 
    * @param channelId Channel GUID 
    * @param userId User GUID 
    * @param notifyProps  
    * @return StatusOK
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsChannelIdMembersUserIdNotifyPropsPut(channelId: kotlin.String, userId: kotlin.String, notifyProps: ChannelNotifyProps) : StatusOK {
        val localVariableBody: kotlin.Any? = notifyProps
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/channels/{channel_id}/members/{user_id}/notify_props".replace("{"+"channel_id"+"}", "$channelId").replace("{"+"user_id"+"}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<StatusOK>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as StatusOK
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Update channel roles
    * Update a user&#39;s roles for a channel. ##### Permissions Must have &#x60;manage_channel_roles&#x60; permission for the channel. 
    * @param channelId Channel GUID 
    * @param userId User GUID 
    * @param roles Space-delimited channel roles to assign to the user 
    * @return StatusOK
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsChannelIdMembersUserIdRolesPut(channelId: kotlin.String, userId: kotlin.String, roles: Roles_1) : StatusOK {
        val localVariableBody: kotlin.Any? = roles
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/channels/{channel_id}/members/{user_id}/roles".replace("{"+"channel_id"+"}", "$channelId").replace("{"+"user_id"+"}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<StatusOK>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as StatusOK
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Patch a channel
    * Partially update a channel by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored. ##### Permissions If updating a public channel, &#x60;manage_public_channel_members&#x60; permission is required. If updating a private channel, &#x60;manage_private_channel_members&#x60; permission is required. 
    * @param channelId Channel GUID 
    * @param body Channel object to be updated 
    * @return Channel
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsChannelIdPatchPut(channelId: kotlin.String, body: Body_24) : Channel {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/channels/{channel_id}/patch".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Channel>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Channel
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get a channel&#39;s pinned posts
    * Get a list of pinned posts for channel.
    * @param channelId Channel GUID 
    * @return PostList
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsChannelIdPinnedGet(channelId: kotlin.String) : PostList {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/channels/{channel_id}/pinned".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<PostList>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PostList
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Update a channel
    * Update a channel. The fields that can be updated are listed as paramters. Omitted fields will be treated as blanks. ##### Permissions If updating a public channel, &#x60;manage_public_channel_members&#x60; permission is required. If updating a private channel, &#x60;manage_private_channel_members&#x60; permission is required. 
    * @param channelId Channel GUID 
    * @param body Channel object to be updated 
    * @return Channel
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsChannelIdPut(channelId: kotlin.String, body: Body_23) : Channel {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/channels/{channel_id}".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Channel>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Channel
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Restore a channel
    * Restore channel from the provided channel id string.  __Minimum server version__: 3.10  ##### Permissions &#x60;manage_team&#x60; permission for the team of channel. 
    * @param channelId Channel GUID 
    * @return Channel
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsChannelIdRestorePost(channelId: kotlin.String) : Channel {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/channels/{channel_id}/restore".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Channel>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Channel
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get channel statistics
    * Get statistics for a channel. ##### Permissions Must have the &#x60;read_channel&#x60; permission. 
    * @param channelId Channel GUID 
    * @return ChannelStats
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsChannelIdStatsGet(channelId: kotlin.String) : ChannelStats {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/channels/{channel_id}/stats".replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ChannelStats>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ChannelStats
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Create a direct message channel
    * Create a new direct message channel between two users. ##### Permissions Must be one of the two users and have &#x60;create_direct_channel&#x60; permission. Having the &#x60;manage_system&#x60; permission voids the previous requirements. 
    * @param body The two user ids to be in the direct message 
    * @return Channel
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsDirectPost(body: kotlin.Array<kotlin.String>) : Channel {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/channels/direct",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Channel>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Channel
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Create a group message channel
    * Create a new group message channel to group of users. If the logged in user&#39;s id is not included in the list, it will be appended to the end. ##### Permissions Must have &#x60;create_group_channel&#x60; permission. 
    * @param body User ids to be in the group message channel 
    * @return Channel
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsGroupPost(body: kotlin.Array<kotlin.String>) : Channel {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/channels/group",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Channel>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Channel
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * View channel
    * Perform all the actions involved in viewing a channel. This includes marking channels as read, clearing push notifications, and updating the active channel. ##### Permissions Must be logged in as user or have &#x60;edit_other_users&#x60; permission.  __Response only includes &#x60;last_viewed_at_times&#x60; in Mattermost server 4.3 and newer.__ 
    * @param userId User ID to perform the view action for 
    * @param body Paremeters affecting how and which channels to view 
    * @return Inline_response_200_5
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsMembersUserIdViewPost(userId: kotlin.String, body: Body_27) : Inline_response_200_5 {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/channels/members/{user_id}/view".replace("{"+"user_id"+"}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Inline_response_200_5>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Inline_response_200_5
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Create a channel
    * Create a new channel. ##### Permissions If creating a public channel, &#x60;create_public_channel&#x60; permission is required. If creating a private channel, &#x60;create_private_channel&#x60; permission is required. 
    * @param body Channel object to be created 
    * @return Channel
    */
    @Suppress("UNCHECKED_CAST")
    fun channelsPost(body: Body_22) : Channel {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/channels",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Channel>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Channel
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get a channel by name and team name
    * Gets a channel from the provided team name and channel name strings. ##### Permissions &#x60;read_channel&#x60; permission for the channel. 
    * @param teamName Team Name 
    * @param channelName Channel Name 
    * @return Channel
    */
    @Suppress("UNCHECKED_CAST")
    fun teamsNameTeamNameChannelsNameChannelNameGet(teamName: kotlin.String, channelName: kotlin.String) : Channel {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/teams/name/{team_name}/channels/name/{channel_name}".replace("{"+"team_name"+"}", "$teamName").replace("{"+"channel_name"+"}", "$channelName"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Channel>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Channel
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Autocomplete channels
    * Autocomplete public channels on a team based on the search term provided in the request URL.  __Minimum server version__: 4.7  ##### Permissions Must have the &#x60;list_team_channels&#x60; permission. 
    * @param teamId Team GUID 
    * @param name Name or display name 
    * @return kotlin.Array<Channel>
    */
    @Suppress("UNCHECKED_CAST")
    fun teamsTeamIdChannelsAutocompleteGet(teamId: kotlin.String, name: kotlin.String) : kotlin.Array<Channel> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("name" to listOf("$name"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/teams/{team_id}/channels/autocomplete".replace("{"+"team_id"+"}", "$teamId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Channel>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Channel>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get deleted channels
    * Get a page of deleted channels on a team based on query string parameters - team_id, page and per_page.  __Minimum server version__: 3.10  ##### Permissions Must be authenticated and have the &#x60;manage_team&#x60; permission. 
    * @param teamId Team GUID 
    * @param page The page to select. (optional, default to 0)
    * @param perPage The number of public channels per page. (optional, default to 60)
    * @return kotlin.Array<Channel>
    */
    @Suppress("UNCHECKED_CAST")
    fun teamsTeamIdChannelsDeletedGet(teamId: kotlin.String, page: kotlin.String, perPage: kotlin.String) : kotlin.Array<Channel> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("page" to listOf("$page"), "perPage" to listOf("$perPage"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/teams/{team_id}/channels/deleted".replace("{"+"team_id"+"}", "$teamId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Channel>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Channel>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get public channels
    * Get a page of public channels on a team based on query string parameters - page and per_page. ##### Permissions Must be authenticated and have the &#x60;list_team_channels&#x60; permission. 
    * @param teamId Team GUID 
    * @param page The page to select. (optional, default to 0)
    * @param perPage The number of public channels per page. (optional, default to 60)
    * @return kotlin.Array<Channel>
    */
    @Suppress("UNCHECKED_CAST")
    fun teamsTeamIdChannelsGet(teamId: kotlin.String, page: kotlin.String, perPage: kotlin.String) : kotlin.Array<Channel> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("page" to listOf("$page"), "perPage" to listOf("$perPage"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/teams/{team_id}/channels".replace("{"+"team_id"+"}", "$teamId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Channel>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Channel>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get a list of channels by ids
    * Get a list of public channels on a team by id. ##### Permissions &#x60;view_team&#x60; for the team the channels are on. 
    * @param teamId Team GUID 
    * @param body List of channel ids 
    * @return kotlin.Array<Channel>
    */
    @Suppress("UNCHECKED_CAST")
    fun teamsTeamIdChannelsIdsPost(teamId: kotlin.String, body: kotlin.Array<kotlin.String>) : kotlin.Array<Channel> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/teams/{team_id}/channels/ids".replace("{"+"team_id"+"}", "$teamId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Channel>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Channel>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get a channel by name
    * Gets channel from the provided team id and channel name strings. ##### Permissions &#x60;read_channel&#x60; permission for the channel. 
    * @param teamId Team GUID 
    * @param channelName Channel Name 
    * @return Channel
    */
    @Suppress("UNCHECKED_CAST")
    fun teamsTeamIdChannelsNameChannelNameGet(teamId: kotlin.String, channelName: kotlin.String) : Channel {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/teams/{team_id}/channels/name/{channel_name}".replace("{"+"team_id"+"}", "$teamId").replace("{"+"channel_name"+"}", "$channelName"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Channel>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Channel
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Search channels
    * Search public channels on a team based on the search term provided in the request body. ##### Permissions Must have the &#x60;list_team_channels&#x60; permission. 
    * @param teamId Team GUID 
    * @param body Search criteria 
    * @return kotlin.Array<Channel>
    */
    @Suppress("UNCHECKED_CAST")
    fun teamsTeamIdChannelsSearchPost(teamId: kotlin.String, body: Body_25) : kotlin.Array<Channel> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/teams/{team_id}/channels/search".replace("{"+"team_id"+"}", "$teamId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Channel>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Channel>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get unread messages
    * Get the total unread messages and mentions for a channel for a user. ##### Permissions Must be logged in as user and have the &#x60;read_channel&#x60; permission, or have &#x60;edit_other_usrs&#x60; permission. 
    * @param userId User GUID 
    * @param channelId Channel GUID 
    * @return ChannelUnread
    */
    @Suppress("UNCHECKED_CAST")
    fun usersUserIdChannelsChannelIdUnreadGet(userId: kotlin.String, channelId: kotlin.String) : ChannelUnread {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/users/{user_id}/channels/{channel_id}/unread".replace("{"+"user_id"+"}", "$userId").replace("{"+"channel_id"+"}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ChannelUnread>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ChannelUnread
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get channels for user
    * Get all the channels on a team for a user. ##### Permissions Logged in as the user, or have &#x60;edit_other_users&#x60; permission, and &#x60;view_team&#x60; permission for the team. 
    * @param userId User GUID 
    * @param teamId Team GUID 
    * @return kotlin.Array<Channel>
    */
    @Suppress("UNCHECKED_CAST")
    fun usersUserIdTeamsTeamIdChannelsGet(userId: kotlin.String, teamId: kotlin.String) : kotlin.Array<Channel> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/users/{user_id}/teams/{team_id}/channels".replace("{"+"user_id"+"}", "$userId").replace("{"+"team_id"+"}", "$teamId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Channel>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Channel>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get channel members for user
    * Get all channel members on a team for a user. ##### Permissions Logged in as the user and &#x60;view_team&#x60; permission for the team. Having &#x60;manage_system&#x60; permission voids the previous requirements. 
    * @param userId User GUID 
    * @param teamId Team GUID 
    * @return kotlin.Array<ChannelMember>
    */
    @Suppress("UNCHECKED_CAST")
    fun usersUserIdTeamsTeamIdChannelsMembersGet(userId: kotlin.String, teamId: kotlin.String) : kotlin.Array<ChannelMember> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/users/{user_id}/teams/{team_id}/channels/members".replace("{"+"user_id"+"}", "$userId").replace("{"+"team_id"+"}", "$teamId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<ChannelMember>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ChannelMember>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

}
