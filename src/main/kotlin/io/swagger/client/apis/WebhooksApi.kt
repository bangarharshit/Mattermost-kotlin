/**
* Mattermost API Reference
* ### API version 4 is stable with the Mattermost server 4.0 release. API version 3 is scheduled for deprecation on January 16th, 2018. [Details here](/#tag/APIv3-Deprecation). Looking for the APIv3 reference? It has moved [here](https://api.mattermost.com/v3). 
*
* OpenAPI spec version: 4.0.0
* Contact: feedback@mattermost.com
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/
package io.swagger.client.apis

import io.swagger.client.models.AppError
import io.swagger.client.models.Body_34
import io.swagger.client.models.Body_35
import io.swagger.client.models.Body_36
import io.swagger.client.models.Body_37
import io.swagger.client.models.IncomingWebhook
import io.swagger.client.models.OutgoingWebhook
import io.swagger.client.models.StatusOK

import io.swagger.client.infrastructure.*

class WebhooksApi(basePath: kotlin.String = "http://your-mattermost-url.com/api/v4") : ApiClient(basePath) {

    /**
    * List incoming webhooks
    * Get a page of a list of incoming webhooks. Optionally filter for a specific team using query parameters. ##### Permissions &#x60;manage_webhooks&#x60; for the system or &#x60;manage_webhooks&#x60; for the specific team. 
    * @param page The page to select. (optional, default to 0)
    * @param perPage The number of hooks per page. (optional, default to 60)
    * @param teamId The ID of the team to get hooks for. (optional)
    * @return kotlin.Array<IncomingWebhook>
    */
    @Suppress("UNCHECKED_CAST")
    fun hooksIncomingGet(page: kotlin.String, perPage: kotlin.String, teamId: kotlin.String) : kotlin.Array<IncomingWebhook> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("page" to listOf("$page"), "perPage" to listOf("$perPage"), "teamId" to listOf("$teamId"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/hooks/incoming",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<IncomingWebhook>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<IncomingWebhook>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get an incoming webhook
    * Get an incoming webhook given the hook id. ##### Permissions &#x60;manage_webhooks&#x60; for system or &#x60;manage_webhooks&#x60; for the specific team or &#x60;manage_webhooks&#x60; for the channel. 
    * @param hookId Incoming Webhook GUID 
    * @return IncomingWebhook
    */
    @Suppress("UNCHECKED_CAST")
    fun hooksIncomingHookIdGet(hookId: kotlin.String) : IncomingWebhook {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/hooks/incoming/{hook_id}".replace("{"+"hook_id"+"}", "$hookId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<IncomingWebhook>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncomingWebhook
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Update an incoming webhook
    * Update an incoming webhook given the hook id. ##### Permissions &#x60;manage_webhooks&#x60; for system or &#x60;manage_webhooks&#x60; for the specific team or &#x60;manage_webhooks&#x60; for the channel. 
    * @param hookId Incoming Webhook GUID 
    * @param body Incoming webhook to be updated 
    * @return IncomingWebhook
    */
    @Suppress("UNCHECKED_CAST")
    fun hooksIncomingHookIdPut(hookId: kotlin.String, body: Body_35) : IncomingWebhook {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/hooks/incoming/{hook_id}".replace("{"+"hook_id"+"}", "$hookId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<IncomingWebhook>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncomingWebhook
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Create an incoming webhook
    * Create an incoming webhook for a channel. ##### Permissions &#x60;manage_webhooks&#x60; for the channel the webhook is in. 
    * @param body Incoming webhook to be created 
    * @return IncomingWebhook
    */
    @Suppress("UNCHECKED_CAST")
    fun hooksIncomingPost(body: Body_34) : IncomingWebhook {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/hooks/incoming",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<IncomingWebhook>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IncomingWebhook
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * List outgoing webhooks
    * Get a page of a list of outgoing webhooks. Optionally filter for a specific team or channel using query parameters. ##### Permissions &#x60;manage_webhooks&#x60; for the system or &#x60;manage_webhooks&#x60; for the specific team/channel. 
    * @param page The page to select. (optional, default to 0)
    * @param perPage The number of hooks per page. (optional, default to 60)
    * @param teamId The ID of the team to get hooks for. (optional)
    * @param channelId The ID of the channel to get hooks for. (optional)
    * @return kotlin.Array<OutgoingWebhook>
    */
    @Suppress("UNCHECKED_CAST")
    fun hooksOutgoingGet(page: kotlin.String, perPage: kotlin.String, teamId: kotlin.String, channelId: kotlin.String) : kotlin.Array<OutgoingWebhook> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("page" to listOf("$page"), "perPage" to listOf("$perPage"), "teamId" to listOf("$teamId"), "channelId" to listOf("$channelId"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/hooks/outgoing",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<OutgoingWebhook>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<OutgoingWebhook>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Delete an outgoing webhook
    * Delete an outgoing webhook given the hook id. ##### Permissions &#x60;manage_webhooks&#x60; for system or &#x60;manage_webhooks&#x60; for the specific team or &#x60;manage_webhooks&#x60; for the channel. 
    * @param hookId Outgoing webhook GUID 
    * @return StatusOK
    */
    @Suppress("UNCHECKED_CAST")
    fun hooksOutgoingHookIdDelete(hookId: kotlin.String) : StatusOK {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/hooks/outgoing/{hook_id}".replace("{"+"hook_id"+"}", "$hookId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<StatusOK>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as StatusOK
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get an outgoing webhook
    * Get an outgoing webhook given the hook id. ##### Permissions &#x60;manage_webhooks&#x60; for system or &#x60;manage_webhooks&#x60; for the specific team or &#x60;manage_webhooks&#x60; for the channel. 
    * @param hookId Outgoing webhook GUID 
    * @return OutgoingWebhook
    */
    @Suppress("UNCHECKED_CAST")
    fun hooksOutgoingHookIdGet(hookId: kotlin.String) : OutgoingWebhook {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/hooks/outgoing/{hook_id}".replace("{"+"hook_id"+"}", "$hookId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<OutgoingWebhook>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as OutgoingWebhook
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Update an outgoing webhook
    * Update an outgoing webhook given the hook id. ##### Permissions &#x60;manage_webhooks&#x60; for system or &#x60;manage_webhooks&#x60; for the specific team or &#x60;manage_webhooks&#x60; for the channel. 
    * @param hookId outgoing Webhook GUID 
    * @param body Outgoing webhook to be updated 
    * @return OutgoingWebhook
    */
    @Suppress("UNCHECKED_CAST")
    fun hooksOutgoingHookIdPut(hookId: kotlin.String, body: Body_37) : OutgoingWebhook {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/hooks/outgoing/{hook_id}".replace("{"+"hook_id"+"}", "$hookId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<OutgoingWebhook>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as OutgoingWebhook
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Regenerate the token for the outgoing webhook.
    * Regenerate the token for the outgoing webhook. ##### Permissions &#x60;manage_webhooks&#x60; for system or &#x60;manage_webhooks&#x60; for the specific team or &#x60;manage_webhooks&#x60; for the channel. 
    * @param hookId Outgoing webhook GUID 
    * @return StatusOK
    */
    @Suppress("UNCHECKED_CAST")
    fun hooksOutgoingHookIdRegenTokenPost(hookId: kotlin.String) : StatusOK {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/hooks/outgoing/{hook_id}/regen_token".replace("{"+"hook_id"+"}", "$hookId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<StatusOK>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as StatusOK
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Create an outgoing webhook
    * Create an outgoing webhook for a team. ##### Permissions &#x60;manage_webhooks&#x60; for the team the webhook is in. 
    * @param body Outgoing webhook to be created 
    * @return OutgoingWebhook
    */
    @Suppress("UNCHECKED_CAST")
    fun hooksOutgoingPost(body: Body_36) : OutgoingWebhook {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/hooks/outgoing",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<OutgoingWebhook>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as OutgoingWebhook
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

}
